import random
import argparse

import hash_chapter1_reimpl_js
import hash_chapter1_impl
import build_autogenerated_chapter1_hash


def get_implementation(is_broken, impl):
    if impl == "js":
        module = hash_chapter1_reimpl_js
    elif impl == "py_ref":
        module = hash_chapter1_impl
    elif impl == "py_extracted":
        module = build_autogenerated_chapter1_hash
    else:
        assert False

    return (module.create_new_broken if is_broken else module.create_new, module.has_key)


def run(test_implementation, is_broken, n_inserts):
    MAX_VAL = 5000
    ref_create_new, ref_has_key = get_implementation(is_broken, "py_ref")
    test_create_new, test_has_key = get_implementation(is_broken, test_implementation)

    numbers = list(set(random.randint(-MAX_VAL, MAX_VAL) for _ in range(n_inserts)))

    ref_keys = ref_create_new(numbers)
    test_keys = test_create_new(numbers)

    for number in numbers:
        if not is_broken:
            assert ref_has_key(ref_keys, number)
            assert test_has_key(test_keys, number)
        else:
            assert ref_has_key(ref_keys, number) == test_has_key(test_keys, number)

    for i in range(n_inserts * 3):
        number = random.randint(-MAX_VAL, MAX_VAL)
        assert ref_has_key(ref_keys, number) == test_has_key(test_keys, number)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Stress-test chapter1 reimplementation')
    parser.add_argument('--is-broken', action='store_true')
    parser.add_argument('--test-implementation', choices=['py_extracted', 'js'], required=True)
    parser.add_argument('--num-inserts',  type=int, default=500)
    args = parser.parse_args()

    run(test_implementation=args.test_implementation,
        is_broken=args.is_broken,
        n_inserts=args.num_inserts)
